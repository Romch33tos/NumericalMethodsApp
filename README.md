# Численные методы

## Описание

Данное приложение предоставляет графический интерфейс для работы с различными численными методами. Оно разработано на языке программирования **C#** с использованием **Windows Presentation Foundation (WPF)**.

## Как установить приложение?

Приложение доступно для скачивания в разделе **[Releases](https://github.com/Romch33tos/NumericalMethodsApp/releases)**.

### Интерфейс главного окна приложения

<img width="400" alt="MainWindow" src="https://github.com/user-attachments/assets/02900931-3180-4112-8573-c8d813528eb9" />

---

## Метод дихотомии (половинного деления)

### Принцип работы

Метод дихотомии — это численный метод для нахождения корней нелинейного уравнения вида `f(x) = 0`. Основная идея заключается в последовательном сужении интервала `[a, b]`, на концах которого функция принимает значения с противоположными знаками, что гарантирует наличие хотя бы одного корня на этом интервале.

**Алгоритм заключается в следующем:**

1. Задается интервал `[a, b]` и точность `ε`, с которой необходимо найти корень.
2. Вычисляется середина текущего интервала:  
   `c = (a + b) / 2`
3. Анализируется значение функции в точке `c`:
   - Если `f(c) = 0` или длина интервала `|b - a|` становится меньше заданной точности `ε`, то `c` считается найденным корнем.
   - Иначе проверяется знак `f(c)`:
     - Если `f(a) * f(c) < 0`, то корень лежит в интервале `[a, c]`. Новым интервалом становится `[a, c]`.
     - Иначе корень лежит в интервале `[c, b]`. Новым интервалом становится `[c, b]`.
4. Шаги 2–3 повторяются до тех пор, пока не достигается заданная точность.

### Интерфейс окна метода дихотомии

<img width="800" alt="DichotomyMethod" src="https://github.com/user-attachments/assets/cc98985c-e629-4470-bf64-e29a7ddbb6c3" />

--- 

## Методы решения систем линейных алгебраических уравнений (СЛАУ)

### Метод Гаусса

Классический метод решения СЛАУ, который заключается в последовательном приведении расширенной матрицы системы к ступенчатому (треугольному) виду с помощью элементарных преобразований (перестановка строк, умножение строки на число, сложение строк). После этого решение находится обратным ходом, начиная с последнего уравнения.

**Алгоритм решения:**
1. **Прямой ход:** Для каждого ведущего элемента (диагонального элемента на текущем шаге):
   - Выбирается ведущая строка (при необходимости производится перестановка строк для избежания деления на ноль).
   - Ведущая строка делится на ведущий элемент, чтобы получить 1 на диагонали.
   - Из всех нижележащих строк вычитается ведущая строка, умноженная на коэффициент, чтобы обнулить элементы текущего столбца под диагональю.
2. **Обратный ход:** После приведения матрицы к верхнетреугольному виду, решение находится снизу вверх:
   - Последняя строка сразу дает значение последней переменной.
   - Каждая предыдущая строка представляет собой уравнение с одной неизвестной, которая выражается через уже найденные переменные.

### Метод Жордана-Гаусса

Модификация метода Гаусса. Матрица системы приводится не к ступенчатому, а к каноническому (единичному) виду, где на главной диагонали находятся 1, а остальные элементы столбцов, кроме диагональных, равны 0. Это позволяет находить решение системы без выполнения обратного хода — значения переменных находятся сразу в последнем столбце преобразованной матрицы.

**Алгоритм решения:**
1. На каждом шаге выбирается ведущий элемент (как в методе Гаусса).
2. Ведущая строка используется для обнуления соответствующего переменного не только в нижележащих, но и в вышележащих строках.
3. После обработки всех столбцов расширенная матрица принимает вид `[A | B']`, где `A` — единичная матрица. Столбец `B'` содержит искомое решение системы.

### Метод Крамера

Теоретический метод, основанный на использование определителей матриц. Если главный определитель системы Δ отличен от нуля, то решение находится по формулам: `x_i = Δ_i / Δ` , где `Δ_i` — определитель матрицы, полученной заменой i-го столбца основной матрицы на столбец свободных членов.

**Алгоритм решения:**
1. Находится определитель `Δ` матрицы коэффициентов системы.
2. Для каждой переменной `x_i` строится матрица, где i-й столбец заменяется столбцом свободных членов, и вычисляется её определитель `Δ_i`.
3. Каждая переменная вычисляется как отношение определителя `Δ_i` к главному определителю `Δ`.

**Особенности применения:** Метод эффективен только для систем с небольшим количеством уравнений (обычно до 4), так как требует вычисления `n + 1` определителя n-го порядка, что при больших значениях n становится вычислительно сложной задачей.

### Интерфейс окна решения СЛАУ

<img width="800" alt="LinearEquationsSolver" src="https://github.com/user-attachments/assets/014ecc34-1606-4b1f-a398-d9a602556cc7" />

---

## Метод золотого сечения

### Принцип работы

Метод золотого сечения — это алгоритм, используемый для поиска экстремума (минимума или максимума) функции на заданном интервале, а также для нахождения нулей функции (корней уравнения). Он основан на делении интервала в пропорции золотого сечения, что обеспечивает более быструю сходимость по сравнению с методом дихотомии.

**Алгоритм для поиска минимума функции:**

1. Задается начальный интервал `[a, b]` и точность `ε`.
2. Вычисляются две внутренние точки по формулам золотого сечения:
   - `x₁ = b - (b - a) / φ`
   - `x₂ = a + (b - a) / φ`
   где `φ = (1 + √5) / 2 ≈ 1.618` — золотое сечение
3. Вычисляются значения функции в точках `x₁` и `x₂`:
   - Если `f(x₁) > f(x₂)`, то минимум находится в интервале `[x₁, b]`
   - Если `f(x₁) < f(x₂)`, то минимум находится в интервале `[a, x₂]`
   - Если `f(x₁) = f(x₂)`, то минимум находится в интервале `[x₁, x₂]`
4. Процесс повторяется до тех пор, пока длина интервала не становится меньше заданной точности `ε`.

### Интерфейс окна метода золотого сечения

<img width="800" alt="GoldenRatioMethod" src="https://github.com/user-attachments/assets/fcfb380d-3337-472d-92d4-63e60eaf105b" />

---

## Метод Ньютона

### Принцип работы

Метод Ньютона — это итерационный численный метод, используемый для нахождения локального минимума функции. Он применяется к производной функции, поскольку экстремумы соответствуют точкам, где первая производная равна нулю.

**Алгоритм для поиска экстремума функции:**

1. Выбирается начальное приближение `x₀`
2. На каждой итерации вычисляется новое приближение по формуле:  
   `xₙ₊₁ = xₙ - f'(xₙ) / f''(xₙ)`
3. Процесс повторяется до достижения заданной точности `ε`, когда `|xₙ₊₁ - xₙ| < ε` или `|f'(xₙ)| < ε`

### Интерфейс окна метода Ньютона

<img width="800" alt="NewtonMethod" src="https://github.com/user-attachments/assets/2a305f54-31f2-4ded-9242-255d3c13605f" />

---

## Олимпиадные сортировки

### Пузырьковая сортировка (Bubble Sort)

**Принцип работы:**
Самый простой алгоритм сортировки, который многократно проходит через массив, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы повторяются до тех пор, пока массив не будет полностью отсортирован.

**Алгоритм:**
1. Выполняется проход по массиву слева направо
2. Сравнивается каждая пара соседних элементов
3. Если элементы расположены в неправильном порядке, выполняется их обмен
4. Шаги 1-3 повторяются до тех пор, пока не выполняется ни одного обмена за полный проход

**Временная сложность:** O(n²) в худшем и среднем случае

### Сортировка вставками (Insertion Sort)

**Принцип работы:**
Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию среди уже отсортированных элементов.

**Алгоритм:**
1. Начинается со второго элемента массива
2. Сравнивается текущий элемент с элементами в отсортированной части
3. Выполняется сдвиг элементов отсортированной части, которые больше текущего элемента, вправо
4. Текущий элемент вставляется в освободившуюся позицию
5. Процесс повторяется для всех последующих элементов
   
**Временная сложность:** O(n²) в худшем случае, O(n) в лучшем случае

### Шейкерная сортировка (Cocktail Shaker Sort)

**Принцип работы:**
Улучшенная версия пузырьковой сортировки, которая проходит по массиву в обоих направлениях - сначала слева направо, затем справа налево.

**Алгоритм:**
1. Выполняется проход слева направо, перемещая наибольший элемент в конец
2. Выполняется проход справа налево, перемещая наименьший элемент в начало
3. Уменьшаются границы неотсортированной части с обоих концов
4. Процесс повторяется до полной сортировки

**Временная сложность:** O(n²)

### Быстрая сортировка (Quick Sort)

**Принцип работы:**
Эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй". Выбирается опорный элемент, массив разбивается на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортируются обе части.

**Алгоритм:**
1. Выбирается опорный элемент
2. Выполняется перераспределение элементов так, чтобы элементы меньше опорного оказались слева, а больше - справа
3. Рекурсивно применяется алгоритм к обеим подмассивам

**Временная сложность:** O(n log n) в среднем случае, O(n²) в худшем случае

### Болотная сортировка (Bogosort)

**Принцип работы:**
Шуточный алгоритм сортировки, который заключается в случайной перестановке элементов массива до тех пор, пока массив не окажется отсортированным.

**Алгоритм:**
1. Проверяется, отсортирован ли массив
2. Если нет - выполняется случайное перемешивание элементов
3. Процесс повторяется до тех пор, пока массив не будет отсортирован

**Временная сложность:** O(n × n!) в среднем случае

### Интерфейс окна олимпиадных сортировок

<img width="800" alt="OlympiadSorting" src="https://github.com/user-attachments/assets/790bde9e-9458-4ed1-88a5-639d7c8fd7a3" />

---

## Вычисление определенного интеграла

### Принцип работы

Численное интегрирование — это приближённое вычисление значения определённого интеграла $\int_{a}^{b} f(x) \, dx$, когда нахождение точного аналитического решения затруднено или невозможно. Методы основаны на аппроксимации площади под кривой $y = f(x)$ на отрезке $[a, b]$ с помощью простых геометрических фигур (прямоугольников, трапеций, парабол).

### Метод левых прямоугольников

**Алгоритм:**
1. Отрезок интегрирования $[a, b]$ разбивается на $n$ равных частей длиной $h = \frac{b - a}{n}$.
2. В каждом частичном отрезке $[x_{i-1}, x_i]$ значение функции принимается равным $f(x_{i-1})$ — значению в левой границе.
3. Приближённое значение интеграла вычисляется по формуле:
   $$I \approx h \cdot \sum_{i=1}^{n} f(x_{i-1})$$

**Геометрическая интерпретация:** Площадь под кривой аппроксимируется суммой площадей прямоугольников, высоты которых равны значениям функции в левых концах отрезков разбиения.

### Метод правых прямоугольников

**Алгоритм:**
1. Отрезок интегрирования $[a, b]$ разбивается на $n$ равных частей длиной $h = \frac{b - a}{n}$.
2. В каждом частичном отрезке $[x_{i-1}, x_i]$ значение функции принимается равным $f(x_i)$ — значению в правой границе.
3. Приближённое значение интеграла вычисляется по формуле:
   $$I \approx h \cdot \sum_{i=1}^{n} f(x_i)$$

**Геометрическая интерпретация:** Площадь под кривой аппроксимируется суммой площадей прямоугольников, высоты которых равны значениям функции в правых концах отрезков разбиения.

### Метод средних прямоугольников

**Алгоритм:**
1. Отрезок интегрирования $[a, b]$ разбивается на $n$ равных частей длиной $h = \frac{b - a}{n}$.
2. В каждом частичном отрезке $[x_{i-1}, x_i]$ значение функции вычисляется в средней точке: $x_{i-1/2} = \frac{x_{i-1} + x_i}{2}$.
3. Приближённое значение интеграла вычисляется по формуле:
   $$I \approx h \cdot \sum_{i=1}^{n} f(x_{i-1/2})$$

**Точность:** Обычно обеспечивает более высокую точность по сравнению с методами левых и правых прямоугольников при том же количестве разбиений, так как ошибка аппроксимации на каждом отрезке имеет меньший порядок.

### Метод трапеций

**Алгоритм:**
1. Отрезок интегрирования $[a, b]$ разбивается на $n$ равных частей длиной $h = \frac{b - a}{n}$.
2. На каждом частичном отрезке $[x_{i-1}, x_i]$ функция аппроксимируется линейной функцией (прямой, проходящей через точки $(x_{i-1}, f(x_{i-1}))$ и $(x_i, f(x_i))$).
3. Приближённое значение интеграла вычисляется по формуле:
   $$I \approx \frac{h}{2} \cdot \left[ f(a) + f(b) + 2 \cdot \sum_{i=1}^{n-1} f(x_i) \right]$$

**Геометрическая интерпретация:** Площадь под кривой аппроксимируется суммой площадей трапеций, основаниями которых являются значения функции на концах каждого отрезка разбиения.

### Метод Симпсона (парабол)

**Алгоритм:**
1. Отрезок интегрирования $[a, b]$ разбивается на **чётное** число $n$ равных частей длиной $h = \frac{b - a}{n}$.
2. На каждом сдвоенном отрезке $[x_{2i-2}, x_{2i}]$ функция аппроксимируется квадратичной параболой, проходящей через три точки: $(x_{2i-2}, f(x_{2i-2}))$, $(x_{2i-1}, f(x_{2i-1}))$, $(x_{2i}, f(x_{2i}))$.
3. Приближённое значение интеграла вычисляется по формуле:
   $$I \approx \frac{h}{3} \cdot \left[ f(a) + f(b) + 4 \cdot \sum_{i=1}^{n/2} f(x_{2i-1}) + 2 \cdot \sum_{i=1}^{n/2 - 1} f(x_{2i}) \right]$$

**Точность:** Имеет более высокий порядок точности по сравнению с предыдущими методами, особенно для гладких функций. Точность метода Симпсона пропорциональна $h^4$, тогда как у метода трапеций — $h^2$, а у методов прямоугольников — $h$.

### Интерфейс окна метода вычисления определенного интеграла

<img width="800" alt="DefiniteIntegralMethod" src="https://github.com/user-attachments/assets/bede163b-790e-43bb-8917-5e0a7e929adf" />
